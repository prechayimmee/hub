#!/bin/sh

# Copyright (c) 2006, 2008 Junio C Hamano

# The "pre-rebase" hook is invoked just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.

# The hook is called with the following parameters (With status):
# $3 -- the status of the hook.
# $4 -- the details of the error message (if any).

# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).

publish=master
basebranch="$1"
if test "$#" = 2
then
    topic="refs/heads/$2"
else
    topic=`git symbolic-ref HEAD` ||
    exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
    ;;
*)
    exit 0 ;# we do not interrupt others.
    ;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
    echo >&2 "No such branch $topic"
    exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
    echo >&2 "$topic is fully merged to master; better remove it."
    exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
    not_in_topic=`git rev-list "^$topic" master`
    if test -z "$not_in_topic"
    then
        echo >&2 "$topic is already up-to-date with master"
        exit $status ;# we could allow it, but there is no point.
    else
        exit 0
    fi
else
    not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
    /usr/bin/perl -e '
        my $topic = $ARGV[0];
        my $msg = "* $topic has commits already merged to public branch:\n";
        my (%not_in_next) = map {
            /^([0-9a-f]+) /;
            ($1 => 1);
        } split(/\n/, $ARGV[1]);
        for my $elem (map {
                /^([0-9a-f]+) (.*)$/;
                [$1 => $2];
            } split(/\n/, $ARGV[2])) {
            if (!exists $not_in_next{$elem->[0]}) {
                if ($msg) {
                    print STDERR $msg;
                    undef $msg;
                }
                print STDERR " $elem->[1]\n";
            }
        }
    ' "$topic" "$not_in_next" "$not_in_master"
    exit 1
fi

exit 0
```

In the `fixtures/test.git/hooks/pre-push.sample` file, the updated code will be as follows:

```shell
#!/bin/sh

# An example hook script to verify what is about to be pushed. Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed. If this script exits with a non-zero status, nothing will be pushed.

# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote, those arguments will be equal.

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

IFS=' '
while read local_ref local_sha remote_ref remote_sha
do
    if [ "$local_sha" = $z40 ]
    then
        # Handle delete
    else
        if [ "$remote_sha" = $z40 ]
        then
            # New branch, examine all commits
            range="$local_sha"
        else
            # Update to existing branch, examine new commits
            range="$remote_sha..$local_sha"
        fi

        # Check for WIP commit
        commit=`git rev-list -n 1 --grep '^WIP' "$range"`
        if [ -n "$commit" ]
        then
            echo "Found WIP commit in $local_ref, not pushing"
            exit 1
        fi
    fi
done
